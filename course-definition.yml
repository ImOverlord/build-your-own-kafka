slug: "kafka"
name: "Build your own Kafka"
short_name: "Kafka"
release_status: "alpha"

description_md: |-
  Kafka is a distributed event streaming platform capable of handling high-throughput message processing. In this challenge, you'll build a toy Kafka clone that's capable of accepting and responding to APIVersions & Fetch API requests. You'll also learn about encoding and decoding messages using the Kafka wire protocol. You'll also learn about handling the network protocol, event loops, TCP sockets and more.

short_description_md: |-
  Learn about TCP sockets, the Kafka wire protocol, event loops and more.

completion_percentage: 15

languages:
  - slug: "go"
  - slug: "python"
  - slug: "rust"

marketing:
  difficulty: medium
  sample_extension_idea_title: "On Disk Storage"
  sample_extension_idea_description: "A Kafka broker that can read and write to disk"
  testimonials:
    - author_name: "Ananthalakshmi Sankar"
      author_description: "Automation Engineer at Apple"
      author_avatar: "https://codecrafters.io/images/external/testimonials/oxta.jpeg"
      link: "https://github.com/anu294"
      text: "There are few sites I like as much that have a step by step guide. The real-time feedback is so good, it's creepy!"

    - author_name: "Patrick Burris"
      author_description: "Senior Software Developer, CenturyLink"
      author_avatar: "https://codecrafters.io/images/external/testimonials/patrick-burris.jpeg"
      link: "https://github.com/Jumballaya"
      text: |-
        I think the instant feedback right there in the git push is really cool.
        Didn't even know that was possible!

stages:
  - slug: "vi6"
    name: "Bind to a port"
    difficulty: easy
    description_md: |-
      In this stage, you'll implement a TCP server that listens on port 9092.

      [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) is the underlying protocol used by protocols like HTTP, SSH and others
      you're probably familiar with. Kafka clients & brokers use TCP to communicate with each other.

      Don't worry if you're unfamiliar with the TCP protocol, or what Kafka clients & brokers are. You'll learn more about this in the
      next stages.

      ### Tests

      The tester will execute your program like this:

      ```bash
      $ ./your_program.sh
      ```

      It'll then try to connect to your TCP server on port 9092. If the connection succeeds, you'll pass this stage.

      ### Notes

      - 9092 is the default port that Kafka uses.
      - If you already have a Kafka server running on your machine and listening on port 9092, you'll see a "port already in use" error when running your code. Try stopping the existing Kafka server and running your code again.

    marketing_md: |-
      In this stage, you'll start a TCP server on port 9092, which is the
      default port that Redis uses.

  - slug: "nv3"
    name: "Respond with a Correlation ID"
    difficulty: easy
    description_md: |-
      In this stage, you'll start implementing the Kafka wire protocol.
      The response structure is as follows:

      ResponseHeader: V0

      ResponseHeader:
        CorrelationId: INT32

      The response is structured as follows:

      ```
      +---------------+--------------------+------------------+
      | MessageLength | ResponseHeader     | ResponseBody     |
      +---------------+--------------------+------------------+
      | INT32         | RESPONSE_HEADER_V0 | RESPONSE_BODY_V3 |
      +---------------+--------------------+------------------+
      ```

      In general each response in the Kafka wire protocol starts with a INT32 containing the length of the entire message, followed by the ResponseHeader and then the ResponseBody.

      ### Tests

      The tester will execute your program like this:

      ```bash
      $ ./your_program.sh
      ```

      It'll then try to connect to your server. It will then send a `APIVersions` request. You don't need to implement the logic to parse this request yet, you need to just send the header with a hardcoded correlation ID.

      In this stage, you don't need to add the actual message length, just send a INT32 with any value. And hardcode the CorrelationId to `7`.

    marketing_md: |-
      In this stage, you'll start implementing the ResponseHeader.